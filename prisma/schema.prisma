// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String? // For credentials provider
  role          UserRole  @default(BUSINESS_OWNER)
  businessId    String?
  business      Business? @relation(fields: [businessId], references: [id], onDelete: Cascade)

  accounts Account[]
  sessions Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([businessId])
  @@index([email])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Business {
  id         String  @id @default(cuid())
  name       String
  email      String
  phone      String?
  address    String?
  timezone   String  @default("UTC")
  dateFormat String  @default("MMM d, yyyy") // Date format for display
  timeFormat String  @default("h:mm a") // Time format (12h or 24h)

  // Branding (Phase 1 - Basic)
  logoUrl      String?
  primaryColor String  @default("#3b82f6") // Default blue
  businessName String // Display name for branding

  // Enhanced Branding (Phase 2)
  secondaryColor  String? // Secondary brand color
  accentColor     String? // Accent color
  backgroundColor String? // Custom background color
  textColor       String? // Custom text color
  fontFamily      String? // Custom font from Google Fonts
  faviconUrl      String? // Favicon URL

  // Domain (Phase 2)
  subdomain String? @unique

  // Booking Rules (Phase 2)
  minimumAdvanceBookingHours Int @default(2) // Minimum hours in advance for booking
  cancellationPolicyHours    Int @default(24) // Hours before booking that cancellation is allowed
  bookingBufferMinutes       Int @default(15) // Buffer time between bookings in minutes

  // Payment Integration (Phase 2)
  paymentProvider          String? // "stripe", "paystack", "flutterwave", or null for no payments
  currency                 String  @default("USD") // Currency code (USD, NGN, GHS, ZAR, KES, etc.)
  stripePublishableKey     String? // Stripe publishable key
  stripeSecretKey          String? @db.Text // Stripe secret key (encrypted)
  stripeWebhookSecret      String? @db.Text // Stripe webhook secret (encrypted)
  paystackPublicKey        String? // Paystack public key
  paystackSecretKey        String? @db.Text // Paystack secret key (encrypted)
  paystackWebhookSecret    String? @db.Text // Paystack webhook secret (encrypted)
  flutterwavePublicKey     String? // Flutterwave public key
  flutterwaveSecretKey     String? @db.Text // Flutterwave secret key (encrypted)
  flutterwaveWebhookSecret String? @db.Text // Flutterwave webhook secret (encrypted)
  requirePaymentDeposit    Boolean @default(false) // Require deposit/payment at booking
  depositPercentage        Int? // Percentage of total price required as deposit (e.g., 50 for 50%)

  // SMS Notifications (Phase 2)
  twilioAccountSid    String? @db.Text
  twilioAuthToken     String? @db.Text
  twilioPhoneNumber   String? // Twilio phone number
  smsRemindersEnabled Boolean @default(false) // Enable SMS reminders

  // WhatsApp Notifications (Phase 2)
  whatsappPhoneNumber          String? // Business WhatsApp phone number (e.g., +1234567890)
  whatsappAccessToken          String? @db.Text // WhatsApp Cloud API access token
  whatsappPhoneNumberId        String? // WhatsApp phone number ID from Meta
  whatsappBusinessAccountId    String? // WhatsApp Business Account ID
  whatsappNotificationsEnabled Boolean @default(false) // Enable/disable WhatsApp notifications

  // Settings
  settings Json? // Store flexible settings as JSON

  // Relations
  users             User[]
  services          Service[]
  bookings          Booking[]
  recurringBookings RecurringBooking[]
  customers         Customer[]
  locations         Location[]
  availability      Availability?
  payments          Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([subdomain])
}

model Location {
  id         String  @id @default(cuid())
  businessId String
  name       String
  address    String?
  phone      String?
  email      String?
  timezone   String? // Override business timezone if needed
  isActive   Boolean @default(true)

  business     Business              @relation(fields: [businessId], references: [id], onDelete: Cascade)
  services     Service[]
  bookings     Booking[]
  availability AvailabilityLocation?

  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  RecurringBooking RecurringBooking[]

  @@index([businessId])
  @@index([isActive])
}

model Service {
  id          String  @id @default(cuid())
  businessId  String
  locationId  String? // Phase 2: Optional location (null = available at all locations)
  name        String
  description String?
  duration    Int // Duration in minutes
  price       Decimal @db.Decimal(10, 2)
  isActive    Boolean @default(true)

  // Additional fields
  bufferTimeBefore        Int?    @default(0) // Minutes needed before service (setup time)
  bufferTimeAfter         Int?    @default(0) // Minutes needed after service (cleanup time)
  imageUrl                String? // Service image URL
  category                String? // Service category (e.g., "Hair Services", "Massage", "Consultation")
  maxCapacity             Int?    @default(1) // Maximum number of people for group services
  cancellationPolicyHours Int? // Hours before booking that cancellation is allowed (null = no cancellation)

  business          Business           @relation(fields: [businessId], references: [id], onDelete: Cascade)
  location          Location?          @relation(fields: [locationId], references: [id], onDelete: SetNull)
  bookings          Booking[]
  recurringBookings RecurringBooking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([businessId])
  @@index([locationId])
  @@index([category])
}

model Customer {
  id         String  @id @default(cuid())
  businessId String
  email      String
  name       String
  phone      String?
  notes      String? @db.Text // Internal notes about the customer

  // Relations
  business          Business           @relation(fields: [businessId], references: [id], onDelete: Cascade)
  bookings          Booking[]
  recurringBookings RecurringBooking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([businessId, email]) // Unique email per business
  @@index([businessId])
  @@index([email])
}

model Booking {
  id                 String  @id @default(cuid())
  businessId         String
  locationId         String? // Phase 2: Optional location
  serviceId          String
  customerId         String? // Phase 2: Link to Customer model
  recurringBookingId String? // Phase 2: Link to RecurringBooking if generated from series
  customerName       String // Keep for backward compatibility
  customerEmail      String
  customerPhone      String?

  startTime DateTime
  endTime   DateTime
  status    BookingStatus @default(PENDING)
  notes     String?

  // Payment (Phase 2)
  amountPaid      Decimal?      @db.Decimal(10, 2) // Amount paid (deposit or full)
  paymentStatus   PaymentStatus @default(PENDING)
  paymentProvider String? // "stripe", "paystack", "flutterwave"
  paymentIntentId String? // Payment intent/transaction ID from provider

  business         Business          @relation(fields: [businessId], references: [id], onDelete: Cascade)
  location         Location?         @relation(fields: [locationId], references: [id], onDelete: SetNull)
  service          Service           @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  customer         Customer?         @relation(fields: [customerId], references: [id], onDelete: SetNull)
  recurringBooking RecurringBooking? @relation(fields: [recurringBookingId], references: [id], onDelete: Cascade)
  payment          Payment? // One-to-one: Payment references this booking via bookingId

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([businessId])
  @@index([businessId, startTime, status]) // Hot path: slots and list by business + date + status
  @@index([locationId])
  @@index([serviceId])
  @@index([startTime])
  @@index([customerEmail])
  @@index([customerId])
  @@index([recurringBookingId])
  @@index([paymentStatus])
}

model Availability {
  id         String @id @default(cuid())
  businessId String @unique
  monday     Json? // Store hours as JSON: { open: "09:00", close: "17:00", isOpen: true }
  tuesday    Json?
  wednesday  Json?
  thursday   Json?
  friday     Json?
  saturday   Json?
  sunday     Json?

  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AvailabilityLocation {
  id         String @id @default(cuid())
  locationId String @unique
  monday     Json? // Store hours as JSON: { open: "09:00", close: "17:00", isOpen: true }
  tuesday    Json?
  wednesday  Json?
  thursday   Json?
  friday     Json?
  saturday   Json?
  sunday     Json?

  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Phase 2: Recurring Bookings
model RecurringBooking {
  id         String  @id @default(cuid())
  businessId String
  locationId String? // Optional location
  serviceId  String
  customerId String? // Link to Customer model

  // Customer details (kept for compatibility and quick access)
  customerName  String
  customerEmail String
  customerPhone String?

  // Recurrence pattern
  frequency           RecurrenceFrequency // DAILY, WEEKLY, BIWEEKLY, MONTHLY
  dayOfWeek           Int? // 0-6 (Sunday = 0) for weekly/biweekly patterns
  dayOfMonth          Int? // 1-31 for monthly patterns
  startTime           String // Time of day (e.g., "14:00" or "2:00 PM")
  startDate           DateTime // First occurrence date
  endDate             DateTime? // Optional end date for the series
  numberOfOccurrences Int? // Optional: total number of bookings to create

  // Status and tracking
  isActive          Boolean   @default(true)
  lastGeneratedDate DateTime? // Last time bookings were generated
  notes             String?   @db.Text

  // Relations
  business Business  @relation(fields: [businessId], references: [id], onDelete: Cascade)
  location Location? @relation(fields: [locationId], references: [id], onDelete: SetNull)
  service  Service   @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  customer Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  bookings Booking[] // Individual bookings generated from this series

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([businessId])
  @@index([locationId])
  @@index([serviceId])
  @@index([customerId])
  @@index([isActive])
  @@index([startDate])
}

enum UserRole {
  BUSINESS_OWNER
  STAFF
  CUSTOMER
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum RecurrenceFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

// Phase 2: Payment Integration
model Payment {
  id         String  @id @default(cuid())
  businessId String
  bookingId  String? @unique // Link to booking (optional for standalone payments)

  // Payment details
  amount   Decimal       @db.Decimal(10, 2)
  currency String        @default("USD")
  status   PaymentStatus @default(PENDING)
  provider String // "stripe", "paystack", "flutterwave"

  // Provider-specific IDs
  providerPaymentId     String? // Payment ID from provider (e.g., Stripe charge ID, Paystack reference)
  providerTransactionId String? // Transaction reference

  // Customer info
  customerEmail String
  customerName  String?
  customerPhone String?

  // Metadata
  metadata      Json? // Store additional provider-specific data
  failureReason String? @db.Text // Reason for failure if status is FAILED

  // Relations
  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)
  booking  Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([businessId])
  @@index([bookingId])
  @@index([status])
  @@index([provider])
  @@index([providerPaymentId])
}
